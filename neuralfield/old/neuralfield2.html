<html>
<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">
<title>Hi there</title>

<style>
body{
    margin: 0;
    padding: 0;
    font-family: Sans !important;
}

#maincanvas {
    margin: 0;
    padding: 0;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    width:100%;
    height:100%;
    /*
    image-rendering: optimizeSpeed;
    image-rendering: -moz-crisp-edges;
    image-rendering: -webkit-optimize-contrast;
    image-rendering: optimize-contrast;
    -ms-interpolation-mode: nearest-neighbor;
    */
}

#canvasdiv {
    margin: 0;
    padding: 0;
    background-color:#00f;
    display: table-cell;
    vertical-align: top;
    width:100%;
    height:100%;
}

#controls {
    display: table-cell;
    min-width: 0px;
    margin:0;
    padding:0px;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    -webkit-box-sizing: border-box; /* Safari/Chrome, other WebKit */
    -moz-box-sizing: border-box;    /* Firefox, other Gecko */
    box-sizing: border-box;         /* Opera/IE 8+ */
    height:100%;
}

</style>

</head>
<body onload="javascript:main()">
<div style='display : table; width : 100%; height : 100%'>
<div style='display : table-row;'>

<div id="controls">
    <!-- <canvas id='hcanvas' ></canvas> -->
</div>
<div id='canvasdiv'>
    <canvas id='maincanvas' >Sorry, this application relies on the HTML5 Canvas element and Javascript. If you have Javascript disabled, try re-enabling it for this page.</canvas>
</div>

</div>
</div>

<script type="text/javascript">

function blur(data,acc,output,w,h,r) {
    /* We need to add padding to get circular convolution with the 
       integral image approach. We assume that there is enough space
       in the acc for this. So make it extra big! */
    var s  = r+1;
    var padstart = s;
    var padafter = r;
    var wa = w+r+s;
    var ha = h+r+s;
    /* With the added padding, we start
       counting the acc with the left-padding. Then compute
       the first row of the acc using the top padding. Then
       compute the right-padding of the top row.  */
    acc[0] = data[(w-s)+w*(h-s)];
    var i    = w*(h-s)+w-s;
    var aci0 = 0;
    var aci1 = -1;
    for (var x=1;x<s;x++) acc[x+aci0] = acc[x+aci1]+data[x+i];
    aci0 += s; aci1 += s; i-=w-s;
    for (var x=0;x<w;x++) acc[x+aci0] = acc[x+aci1]+data[x+i];
    aci0 += w; aci1 += w;
    for (var x=0;x<r;x++) acc[x+aci0] = acc[x+aci1]+data[x+i];
    /* Next we compute the remainder of the top padding. Each row of the 
       top padding has three parts: the left padding, the main part, and
       the right padding. The structure of the code here is a bit
       naughty but it preserves the symmetry with the block above which
       I think is useful for comprehension. l is a running accumulator
       for the row. It needs to be update before we compute the acc value */
    for (var Y=1;Y<ha;Y++) {
        var i = w*(1+Y-s+(Y<s?h:Y<h+s?0:-h))-s;
        var l=0.0;
        var aci0 = wa*Y;
        var aci1 = aci0-wa;
        for (var x=0;x<s;x++) acc[x+aci0] = acc[x+aci1] + (l+=data[x+i]);
        aci0 += s; aci1 += s; i-=w-s;
        for (var x=0;x<w;x++) acc[x+aci0] = acc[x+aci1] + (l+=data[x+i]);
        aci0 += w; aci1 += w;
        for (var x=0;x<r;x++) acc[x+aci0] = acc[x+aci1] + (l+=data[x+i]);
    }
    /* compute the box filter */
    var a1 = 0;
    var a2 = (r+s)*(1+wa);
    var a3 = wa*(r+s);
    var a4 = r+s;
    var normalize = 1.0 / (r+s);
    normalize *= normalize;
    for (var y=0;y<h;++y)
    for (var x=0;x<w;++x) {
	    var i = y*wa+x;
		var sum = 0;
		sum += acc[i+a1];
		sum += acc[i+a2];
		sum -= acc[i+a3];
		sum -= acc[i+a4];
		output[y*w+x] = sum*normalize+0.5;
    }
}

function main() {

    /* Prepare rendering canvas */
    var canvas = document.getElementById('maincanvas');
    var frame  = document.getElementById('canvasdiv');
    var downscale = 1;
    var W  = frame.clientWidth >>downscale;
    var H  = frame.clientHeight>>downscale;
    canvas.width  = W; 
    canvas.height = H; 
    var ctx = canvas.getContext('2d');
    var imageData = ctx.getImageData(0,0,W,H);
    var data = new Uint32Array(imageData.data.buffer);
    for (var y=0;y<H;y++)
        for (var x=0;x<W;++x)
            data[x+W*y] = 0xff000000 | ((x^y)&1)*0xffffff;
    ctx.putImageData(imageData, 0, 0);    
    
    /* Prepare histogram canvas */
    /*
    var hcanvas = document.getElementById('hcanvas');
    hw=64*3; 
    hh=128*3;
    hcanvas.width  = hw; 
    hcanvas.height = hh; 
    var hctx  = hcanvas.getContext('2d');
    var himg  = hctx.getImageData(0,0,hw,hh);
    var hdata = new Uint32Array(himg.data.buffer);
    */
    
    /* Try creating some sliders */
    

    /* Let's prepare 3 fields for now */
    /* I'm not sure what data-type to use. Maybe uint8 for now */
    nbytes = W*H;
    var data1 = new Uint8ClampedArray(new ArrayBuffer(nbytes));
    var data2 = new Uint8ClampedArray(new ArrayBuffer(nbytes));
    
    //var acc   = new Float32Array(ArrayBuffer(8*nbytes*2));
    var acc   = new Uint32Array(new ArrayBuffer(8*nbytes*2));
    
    for (var y=0;y<H;++y)
        for (var x=0;x<W;++x)
            data1[x+W*y] = 0xff*(((x^y)>>5)&1);

    var start = +new Date();
    blur(data1,acc,data2,W,H,3);
    blur(data2,acc,data1,W,H,3);
    var end =  +new Date();
    var diff = end - start;
    console.log('Blurs took '+diff+' ms, target is '+(1000/25/2));
        
    for (var y=0;y<H;++y) {
        for (var x=0;x<W;++x) {
            data[x+W*y] = 0xff000000 | data1[x+W*y]*0x010001 | data2[x+W*y]*0x0100;// (acc[x+W*y]*.001);
        }
    }
    ctx.putImageData(imageData, 0, 0);      
    
	function f(x) { return 256/(1+Math.exp(-x));   };
	function g(x) { return -Math.log(256.0/x-1.0); };    
    var buffF  = new Uint8ClampedArray(new ArrayBuffer(256*8));
    for (var i=0;i<256*8;i++) {
        buffF[i] = f((i-256*4)/(256.0*4));
    }
    function F(x) { if (x<-1024) x=-1024; else if (x>1023) x=1023; return buffF[x+1024]; }
    
    var buffE  = new Uint8ClampedArray(new ArrayBuffer(nbytes));
    var buffI  = new Uint8ClampedArray(new ArrayBuffer(nbytes));
    var buffA  = new Uint8ClampedArray(new ArrayBuffer(nbytes));
    var temp   = new Uint8ClampedArray(new ArrayBuffer(nbytes));
    var temp2  = new Uint8ClampedArray(new ArrayBuffer(nbytes));
    var buffEC = new Uint8ClampedArray(new ArrayBuffer(nbytes));
    var buffIC = new Uint8ClampedArray(new ArrayBuffer(nbytes));
    
	var rand = Math.floor(Math.random()*0x1000000);
    for (var y=0;y<H;++y)
        for (var x=0;x<W;++x)
            buffE[x+W*y] = ((rand^=rand>>2^rand<<1)&0xff);
    for (var y=0;y<H;++y)
        for (var x=0;x<W;++x)
            buffI[x+W*y] = ((rand^=rand>>2^rand<<1)&0xff);
    
    var dte = 0.7;
    var dti = dte*0.4;
    var dta = dte*0.01;
    var fe = 500;
    var fi = 0;
    var se = 1;
    var si = 4;
    var wee = 7;
    var wie = 5;
    var wei = 7;
    var wii = 1;
    var wia = 1;
    var wai = 1;
    var wea = 0.0;
    var nn  = 50;
    
    var running = 1;
    var framerate = 0.0;
    var frametau  = 0.1;
    var lastframe = +new Date();
    var part1 = 0.0;
    var part2 = 0.0;
    
    for (var y=0;y<H;++y) {
        for (var x=0;x<W;++x) {
		    var index = x+W*y;
            data[index] = 0xff000000;
        }
    }
    
    function iterate() {
        /* Simulate a neural field model. Two population for now. Usual 
           steps:
           convolve field with their interaction kernels.
           update.
        */
		//console.log('dte=',dte,'dti=',dti,'fe=',fe,'fi=',fi,'se=',se,'si=',si,'ee=',wee,'ei=',wei,'ie=',wie,'ii=',wii,'noise=',nn);
		
		var rand = Math.floor(Math.random()*0x1000000);
		
        var start = +new Date();
        blur(buffE,acc,temp,W,H,se);
        blur(temp,acc,buffEC,W,H,se);
        blur(buffI,acc,temp,W,H,si);
        blur(temp,acc,buffIC,W,H,si);
        var end =  +new Date();
        var diff = end - start;
        part1 += frametau*(diff-part1);
        //console.log('Blurs took '+diff+' ms, target is '+(1000/25/2));
                        
        //for (var i=0;i<128;i++) ehist1[i]=ihist1[i]=ehist2[i]=ihist2[i]=0;
        
        var start = +new Date();
        for (var y=0;y<H;++y) {
            for (var x=0;x<W;++x) {
			    var index = x+W*y;
			    var E  = buffE[index];
			    var I  = buffI[index];
			    //var A  = buffA[index];
			    var CE = buffEC[index];
			    var CI = buffIC[index];
			    var noise = 0;//((rand^=rand>>2^rand<<1)&0xff)*0.0039-0.5;
			    
			    //var NE = dte*(-E+f(wee*CE-wei*CI+fe+nn*noise))+E;
			    //var NI = dti*(-I+f(wie*CE-wii*CI+fi+nn*noise)-A*wia)+I;
			    //var NA = dta*(-A+I*wai);
			    var NE = dte*(-E+F(wee*CE-wei*CI+fe+nn*noise))+E;
			    var NI = dti*(-I+F(wie*CE-wii*CI+fi))+I;
			    //var NA = dta*(E-A);
			    buffE[index] = NE;
			    buffI[index] = NI;
			    //buffA[index] = NA;
			    data[index] = 0xff000000|(NE<<16)|(NI<<8);//|NA;
			    
            }
        }
        var end =  +new Date();
        var diff = end - start;
        part2 += frametau*(diff-part2);
        //console.log('Dynamics took '+diff+' ms, target is '+(1000/25/2));
        
        ctx.putImageData(imageData, 0, 0);      
        //hctx.putImageData(himg, 0, 0);      
    
        var currframe = +new Date();
        var diff = currframe - lastframe;
        var rate = 1000.0/diff;
        framerate = (1-frametau)*framerate+frametau*rate;
        ctx.fillStyle = "white";
        ctx.fillText(framerate+' fps',5,15);   
        ctx.fillText(part1+' ms',5,25);   
        ctx.fillText(part2+' ms',5,35);   
        
        lastframe = currframe;
        
        /** Apparently animations loops live in the event thread like so*/
        if (running) setTimeout(iterate,0);//1000/30);
    }
    
	canvas.onmousedown = function(e) {
		running = 1-running;
		if (running) setTimeout(iterate, 0);
	};
	
    
    console.log('starting');
    setTimeout(iterate, 0);
    
}

</script>

</body>
</html>



